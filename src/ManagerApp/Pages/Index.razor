@page "/"
@using Common.Models
@using FileHelpers;
@using ManagerApp.Models
@using System.Text
@using static ManagerApp.Utils.Enums

@inject IJSRuntime JS
@inject HttpClient _HttpCLient
<PageTitle>Index</PageTitle>

<h1>Rudimental crypto tax calculator</h1>

<div class="row mb-3">
    <div class="col-12">
    <label for="formFile" class="form-label">Import CSV transactions</label>
    <InputFile OnChange="UploadFile" class="form-control" id="formFile"></InputFile>
    </div>
</div>
<div class="row mb-3">
    <div class="col-12">
        <HxGrid SelectedDataItem="selectedDataItem"
                SelectedDataItemChanged="HandleSelectedDataItemChanged"
                TItem="CryptoTransactionRecordImport"
                Responsive="true"
                DataProvider="ClientSideProcessingDataProvider"
                PageSize="10">
            <Columns>
                <HxGridColumn TItem="CryptoTransactionRecordImport" HeaderText="Trade" SortKeySelector="@(item => item.TransactionType)" IsDefaultSortColumn="true">
                    <ItemTemplate Context="item">
                        @if (selectedDataItem == item)
                        {
                            <HxSelect TItem="string" TValue="string" Data="@Enum.GetNames(typeof(TradeType)).ToList()" @bind-Value="@item.TransactionType" TextSelector="@(p => p)" ValueSelector="@(p => p)" Nullable="true" NullText="-select name-" NullDataText="Loading..." />
    
                            
                               
                             
                        }
                        else
                        {
                            <div>@item.TransactionType</div>
                        }
                    </ItemTemplate>
                </HxGridColumn>
             
            </Columns>
        </HxGrid>


    </div>
</div>

@if (_showLoader)
{
    <div class="mb-3">
        <div style="display:grid;place-items:center;margin-top:10%">
            <span class="loader">Processing, please wait...</span>
        </div>
    </div>
}



@code {

    private CryptoTransactionRecordImport selectedDataItem;
    private List<CryptoTransactionRecordImport> localEditableDataItem { get; set; } = new();
    private IEnumerable<string> TradeTypes = Enum.GetNames(typeof(TradeType)).ToList();
    private List<CryptoTransactionRecord> _importedRecords = new();

    private bool _showLoader = false;

    protected override void OnInitialized()
    {
        localEditableDataItem.Add(new CryptoTransactionRecordImport()
            {
                TransactionDate = DateTime.Now.Date,
                Sequence = 1,
                TransactionType = "buy",
                AssetType = "crypto"

            });
    }

    private Task<GridDataProviderResult<CryptoTransactionRecordImport>> ClientSideProcessingDataProvider(GridDataProviderRequest<CryptoTransactionRecordImport> request)
    {
        return Task.FromResult(request.ApplyTo(localEditableDataItem));
    }

    private async Task HandleSelectedDataItemChanged(CryptoTransactionRecordImport newSelectedDataItem)
    {
        if (selectedDataItem != null)
        {
            // TODO: add your logic to save item changes here, the item which was selected (edited) is in selectedDataItem
            await Task.Delay(200); // simulates API call (saving changes itself)
            Console.WriteLine("Saving... " + selectedDataItem);
        }

        selectedDataItem = newSelectedDataItem;
    }


    private async void UploadFile(InputFileChangeEventArgs e)
    {
        //Read file into stream
        using (var ms = e.File.OpenReadStream())
        {
            using (TextReader reader = new StreamReader(ms))
            {
                var readerText = await reader.ReadToEndAsync();
                using (var engine = new FileHelperAsyncEngine<CryptoTransactionRecordImport>())
                {

                    using (engine.BeginReadString(readerText))
                    {
                        _showLoader = true;
                        StateHasChanged();
                        foreach (var record in engine)
                        {
                            _importedRecords.AddRange(Utils.Taxify.Flatten(record));
                        }
                    }
                }
            }
        }

        await ExportRecords(_importedRecords);
        _showLoader = false;
        StateHasChanged();

    }



    private async Task<List<ExchangeRate>> LoadCryptoExchangeRates(string symbol, int startYear = 2015, int endYear = 2022)
    {
        var currentIterationYear = startYear;
        List<ExchangeRate> cryptoExchangeRateCollection = new List<ExchangeRate>();
        while (currentIterationYear <= endYear)
        {
            try
            {

                var cryptoExchangeRates = await _HttpCLient.GetFromJsonAsync<List<ExchangeRate>>($"/config/{currentIterationYear}/{symbol}.json");
                if (cryptoExchangeRates is not null && cryptoExchangeRates.Count > 0)
                {
                    cryptoExchangeRateCollection.AddRange(cryptoExchangeRates);
                }
            }
            catch (Exception ex)
            {
               // Console.WriteLine($"error loading file /config/{currentIterationYear}/{symbol}.json -> {ex.Message}");
            }
            finally
            {
                currentIterationYear++;
            }
        }

        return cryptoExchangeRateCollection;


    }

    private async Task ExportRecords(List<CryptoTransactionRecord> records)
    {
        //flattern
        //var flattenedRecords = Utils.Taxify.DailyConsolidation(records);
        //Get unique symbols
        var symbols = records.Select(x => x.AmountAssetType).Distinct();
        List<ExchangeRate> AllExchangeRates = new();
        foreach (var symbol in symbols)
        {

            var startYear = records.Where(x => x.AmountAssetType == symbol).MinBy(x => x.TransactionDate).TransactionDate.Year;
            var endYear = records.Where(x => x.AmountAssetType == symbol).MaxBy(x => x.TransactionDate).TransactionDate.Year;
            var response = await LoadCryptoExchangeRates(symbol.ToLower(), startYear, endYear);
            if (response is not null && response.Count > 0)
            {
                AllExchangeRates.AddRange(response);
            }
        }

        //augment and look up records with no predifined exchange rate value
        var recordsWithNoPredefinedExchangeRates = records.Where(x => x.ExchangeRateValue == 0 || x.ExchangeRateValue is null);
        foreach (var record in recordsWithNoPredefinedExchangeRates)
        {
            var UTCTransactionDateTime = record.TransactionDate.ToUniversalTime();
           
            //lookup exchange rate
            List<ExchangeRate> scopedExchangeRates = new();
            scopedExchangeRates.AddRange(AllExchangeRates.Where(x => x.Date.Date == UTCTransactionDateTime.Date && x.Symbol.ToLower() == record.AmountAssetType));
            if (scopedExchangeRates is not null && scopedExchangeRates.Count() > 0)
            {
                //augment

                record.ExchangeRateCurrency = scopedExchangeRates?.FirstOrDefault()?.ExchangeCurrency ?? "Unkonwn";
                 record.UsesManualAssignedExchangeRate = false;
                if (record.TransactionType.ToLower() == "buy")
                {
                    record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().High);
                }
                else
                {
                    record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().Low);
                }

                var exchangeRates = new List<string>() { "aud", "usd" };
                if (!exchangeRates.Contains(record.ExchangeRateCurrency.ToLower()))
                {
                    //lookup exchange rate
                    scopedExchangeRates = new();

                    scopedExchangeRates.AddRange(AllExchangeRates.Where(x => x.Date.Date == UTCTransactionDateTime.Date && x.Symbol.ToLower() == record.ExchangeRateCurrency.ToLower()));
                    if (scopedExchangeRates is not null && scopedExchangeRates.Count() > 0)
                    {
                        //augment
                        //we will use the highest exchange rate for buys and lowest for sells.
                        //exchangeRateValue = 0d;
                        record.ExchangeRateCurrency = scopedExchangeRates?.FirstOrDefault()?.ExchangeCurrency ?? "Unkonwn";
                        record.UsesManualAssignedExchangeRate = false;
                        //convert

                        if (record.TransactionType.ToLower() == "buy")
                        {
                            record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().High) * record.ExchangeRateValue;
                        }
                        else
                        {
                            record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().Low) * record.ExchangeRateValue;
                        }


                    }
                }

                //deal with NFTs, and calculate totals
                if (record.IsNFT)
                {
                    //check value and convert to AUD

                    scopedExchangeRates = new();
                    scopedExchangeRates.AddRange(AllExchangeRates.Where(x => x.Date.Date == UTCTransactionDateTime.Date && x.Symbol.ToLower() == record.ValueAssetType.ToLower()));
                    if (scopedExchangeRates is not null && scopedExchangeRates.Count() > 0)
                    {
                        //augment
                        record.UsesManualAssignedExchangeRate = false;
                        record.Value = Convert.ToDouble(scopedExchangeRates?.FirstOrDefault()?.High) * record.Value;
                        record.ValueAssetType = scopedExchangeRates?.FirstOrDefault()?.ExchangeCurrency;
                        record.ExchangeRateValue = record.Value / record.Amount;
                        record.ExchangeRateCurrency = record.ValueAssetType;
                    }
                }
                else
                {
                    record.UsesManualAssignedExchangeRate = false;
                    record.Value = record.Amount * record.ExchangeRateValue;
                    record.ValueAssetType = record.ExchangeRateCurrency;
                }
            }


        }


        //augment and skip looking up records where exchange rates are predifined
        var recordsWithPredefinedExchangeRates = records.Where(x => x.ExchangeRateValue > 0);
        foreach (var record in recordsWithPredefinedExchangeRates)
        {
            var UTCTransactionDateTime = record.TransactionDate.ToUniversalTime();
           
            //indicates we are using the user supplied exchange rate
            record.UsesManualAssignedExchangeRate = true;
            
            List<ExchangeRate> scopedExchangeRates = new();
            var exchangeRates = new List<string>() { "aud", "usd" };
            if (!exchangeRates.Contains(record.ExchangeRateCurrency.ToLower()))
            {
                //overwrite flag as we will need to lookup the exchange rate
                record.UsesManualAssignedExchangeRate = false;
                //lookup exchange rate
                scopedExchangeRates = new();

                scopedExchangeRates.AddRange(AllExchangeRates.Where(x => x.Date.Date == UTCTransactionDateTime.Date && x.Symbol.ToLower() == record.ExchangeRateCurrency.ToLower()));
                if (scopedExchangeRates is not null && scopedExchangeRates.Count() > 0)
                {
                    //augment
                    
                    record.ExchangeRateCurrency = scopedExchangeRates?.FirstOrDefault()?.ExchangeCurrency ?? "Unkonwn";
                    //convert

                    if (record.TransactionType.ToLower() == "buy")
                    {
                        record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().High) * record.ExchangeRateValue;
                    }
                    else
                    {
                        record.ExchangeRateValue = Convert.ToDouble(scopedExchangeRates.FirstOrDefault().Low) * record.ExchangeRateValue;
                    }


                }
            }

            //deal with NFTs, and calculate totals
            if (record.IsNFT)
            {
                //check value and convert

                scopedExchangeRates = new();
                scopedExchangeRates.AddRange(AllExchangeRates.Where(x => x.Date.Date == UTCTransactionDateTime.Date && x.Symbol.ToLower() == record.ValueAssetType.ToLower()));
                if (scopedExchangeRates is not null && scopedExchangeRates.Count() > 0)
                {
                    //augment
                    //we will use the highest exchange rate for buys and lowest for sells.
                    //overwrite flag as we will need to lookup the exchange rate
                    record.UsesManualAssignedExchangeRate = false;
                    record.Value = Convert.ToDouble(scopedExchangeRates?.FirstOrDefault()?.High) * record.Value;
                    record.ValueAssetType = scopedExchangeRates?.FirstOrDefault()?.ExchangeCurrency;
                    record.ExchangeRateValue = record.Value / record.Amount;
                    record.ExchangeRateCurrency = record.ValueAssetType;
                }
            }
            else
            {

                record.Value = record.Amount * record.ExchangeRateValue;
                record.ValueAssetType = record.ExchangeRateCurrency;
            }
        }







        var engine = new FileHelperEngine<CryptoTransactionRecord>();
        engine.HeaderText = engine.GetFileHeader();

        var outputString = engine.WriteString(Utils.Taxify.DailyConsolidation(records)); // flattenedRecords);
        using (var outputStream = new MemoryStream(Encoding.UTF8.GetBytes(outputString)))
        {
            using (var streamRef = new DotNetStreamReference(stream: outputStream))
            {
                //download using JS
                string fName = string.Concat(DateTime.Now.ToString("yyyy-MM-dd"), "_", DateTime.Now.Ticks, ".csv");
                await JS.InvokeVoidAsync("downloadFile", fName, streamRef);
            }
        }
    }
  

}